<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wordle Art</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #18181b;
      color: #f4f4f5;
      height: 100%;
      width: 100%;
      box-sizing: border-box;
    }
    body {
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .top-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      position: fixed;
      top: 0;
      left: 0;
      padding: 16px 0;
      background: #23232a;
      box-shadow: 0 2px 8px rgba(0,0,0,0.24);
      z-index: 10;
    }
    .btn-group {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
    }
    .solution-btn, .reset-btn {
      padding: 12px 36px;
      background: #2563eb;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-size: 1.25rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    .solution-btn:hover, .reset-btn:hover {
      background: #1e40af;
    }
    .reset-btn {
      background: #44444c;
      color: #f4f4f5;
    }
    .reset-btn:hover {
      background: #787c7e;
    }
    .container {
      margin-top: 120px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 60vh;
      width: 100vw;
      max-width: 100vw;  
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(5, minmax(48px, 1fr));
      grid-template-rows: repeat(6, minmax(48px, 1fr));
      gap: 0.45vw;
      background: #23232a;
      padding: 1.5vw;
      border-radius: 8px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.25);
      max-width: 600px;    
      width: 100%;         
      margin: 0 auto;      
      max-height: 90vh;    
    }
    .cell {
      aspect-ratio: 1 / 1;
      width: 100%;
      height: 100%;
      background: #27272f;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.2rem, 6vw, 2.5rem);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s, opacity 0.4s;
      border: 5px solid #44444c;
      color: #f4f4f5;
      opacity: 1;
      box-sizing: border-box;
    }
    .cell.green { background: #538d4e; color: #fff; }
    .cell.orange { background: #b59f3b; color: #fff; }
    .cell.gray { background: #3a3a3c; color: #fff; }
    .cell.hidden {
      opacity: 0;
    }
    .cell.loading {
      animation: fadeInOut 1s linear infinite;
    }
    .cell.locked {
      cursor: not-allowed;
      opacity: 0.7;
    }
    @keyframes fadeInOut {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
    @keyframes shake {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-8px); }
      40%  { transform: translateX(8px); }
      60%  { transform: translateX(-6px); }
      80%  { transform: translateX(6px); }
      100% { transform: translateX(0); }
    }

    .shake-row {
      animation: shake 0.5s ease;
    }
    
    @keyframes border-fade-red {
      0% {
        border-color: #44444c;
        box-shadow: none;
      }
      10%,
      70% {
        border-color: rgba(236, 17, 17, 0.5);
        box-shadow: 0 0 0 2px rgba(254,90,90,0.14);
      }
      100% {
        border-color: #44444c;
        box-shadow: none;
      }
    }
    .red-border-fade {
      animation: border-fade-red 0.75s;
    }
    .pattern-input-grid {
      display: flex;
      gap: 5px;
      margin-bottom: 20px;
    }

    #pattern-input {
      display: none;
    }

    .pattern-menu.visible + #pattern-input {
      display: flex;
    }

    .pattern-cell {
      width: 40px;
      height: 40px;
      background-color: #aaa;
      border: 1px solid #999;
      cursor: pointer;
    }
    .pattern-cell.green   { background-color: #4CAF50; }
    .pattern-cell.orange  { background-color: #FFA500; }
    .pattern-cell.gray    { background-color: #aaa;     }

    .pattern-menu {
      position: fixed;
      top: 0;
      right: -320px;
      width: 300px;
      height: 100%;
      background: #27272f;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto;
      padding: 15px;
      transition: right 0.3s ease-in-out;
      z-index: 9999;
      border-left: 1px solid #ddd;
    }

    .pattern-menu.visible { right: 0; }

    .pattern-box {
      width: 20px;
      height: 20px;
      margin-right: 4px;
      border: 1px solid #ccc;
    }

    button#pattern-menu-button {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      padding: 10px 15px;
      background-color: #007BFF;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button#pattern-menu-button:hover {
      background-color: #0056b3;
    }
    .notification {
      position: fixed;
      top: 32px;
      left: 50%;
      transform: translateX(-50%);
      background: #23232a;
      color: #fff;
      padding: 18px 32px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.24);
      font-size: 1.15rem;
      opacity: 0.97;
      z-index: 9999;
      pointer-events: none;
      transition: opacity 0.5s;
      max-width: 90vw;
      text-align: center;
      word-break: break-word;
    }
    .notification.hide {
      opacity: 0;
      transition: opacity 0.5s;
    }
    /* Responsive adjustments */
    @media (max-width: 700px) {
      .container {
        margin-top: 80px;
        min-height: 40vh;
      }
      .grid {
        gap: 2vw;
        padding: 2vw;
        border-radius: 10px;
      }
      .btn-group {
        gap: 12px;
      }
      .solution-btn, .reset-btn {
        padding: 10px 18px;
        font-size: 1rem;
      }
      .notification {
        padding: 12px 8px;
        font-size: 1rem;
      }
    }
    @media (max-width: 450px) {
      .container {
        margin-top: 60px;
      }
      .grid {
        gap: 1vw;
        padding: 1vw;
      }
      .solution-btn, .reset-btn {
        padding: 8px 6px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div class="btn-group">
      <button class="solution-btn">Find solution for today</button>
      <button class="reset-btn">Reset</button>
      <button id="pattern-menu-button">Show Matching Patterns</button>
    </div>
  </div>
  <div class="container">
    <div class="grid" id="wordleGrid"></div>
  </div>
  <div id="notification" class="notification" style="display:none"></div>
  <div id="pattern-menu" class="pattern-menu hidden">
    <button id="close-menu-button" style="margin-bottom: 10px;">× Close</button>
  </div>
  <div id="pattern-input" class="pattern-input-grid">
    <div class="pattern-cell"></div>
    <div class="pattern-cell"></div>
    <div class="pattern-cell"></div>
    <div class="pattern-cell"></div>
    <div class="pattern-cell"></div>
  </div>
  <script>
    const API_ENDPOINT = "http://127.0.0.1:8080"
    const colors = ["green", "orange", "gray"];
    const colorToChar = {
      "green": "G",
      "orange": "O",
      "gray": "#"
    };

    const grid = document.getElementById('wordleGrid');
    let cells = [];
    let colorInputLocked = false;

    for (let row = 0; row < 6; row++) {
      for (let col = 0; col < 5; col++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.state = "2";
        cell.classList.add('gray');
        cell.textContent = "";
        cell.addEventListener('click', function() {
          if (cell.classList.contains('loading') || colorInputLocked) return;
          let state = parseInt(cell.dataset.state);
          state = (state + 1) % colors.length;
          cell.dataset.state = state;
          cell.className = 'cell';
          if (colors[state]) cell.classList.add(colors[state]);
        });
        grid.appendChild(cell);
        cells.push(cell);
      }
    }

    function showNotification(message, duration=2500) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.style.display = 'block';
      notification.classList.remove('hide');
      setTimeout(() => {
        notification.classList.add('hide');
        setTimeout(() => {
          notification.style.display = 'none';
        }, 500);
      }, duration);
    }

    function startLoadingAnimation() {
      cells.forEach(cell => {
        cell.classList.add('loading');
      });
    }
    function stopLoadingAnimation() {
      cells.forEach(cell => {
        cell.classList.remove('loading');
      });
    }

    function revealWordsWithFade(words, cells, isFullSolution) {
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.add("hidden");
        cell.classList.remove("shake-row");
        cell.classList.remove("red-border-fade");
      });

      const totalRows = 6;
      const columns = 5;
      let shakeApplied = false;

      function revealRow(row) {
        if (row >= totalRows) return;

        const word = words[row] || "";
        const isEmpty = word === "";

        for (let col = 0; col < columns; col++) {
          const idx = row * columns + col;
          cells[idx].textContent = word[col] || "";
          void cells[idx].offsetWidth;
          cells[idx].classList.remove('hidden');
        }

        // Apply shake/red-border only if it’s not a full solution
        if (!isFullSolution && isEmpty && !shakeApplied) {
          const rowStart = row * columns;
          for (let i = 0; i < columns; i++) {
            const cell = cells[rowStart + i];
            cell.classList.add("shake-row", "red-border-fade");
            setTimeout(() => {
              cell.classList.remove("red-border-fade");
            }, 1000);
          }
          shakeApplied = true;
        }

        setTimeout(() => revealRow(row + 1), 100);
      }

      revealRow(0);
    }

    function setColorInputLocked(lock) {
      colorInputLocked = lock;
      cells.forEach(cell => {
        if (lock) {
          cell.classList.add('locked');
        } else {
          cell.classList.remove('locked');
        }
      });
    }

    function resetGrid() {
      cells.forEach(cell => {
        cell.textContent = "";
        cell.dataset.state = "2";
        cell.className = "cell gray"; 
      });
      setColorInputLocked(false);
    }

    document.querySelector('.solution-btn').addEventListener('click', function() {
      let colorString = "";
      cells.forEach(cell => {
        let colorClass = colors[parseInt(cell.dataset.state)];
        colorString += colorToChar[colorClass];
      });

      startLoadingAnimation();
      setColorInputLocked(true);

      fetch(`${API_ENDPOINT}/get_words`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ colors: colorString })
      })
      .then(response => response.json())
      .then(data => {
        stopLoadingAnimation();
        if ('Response' in data) {
          console.log("API Response Code:", data.Response);
        }
        if ('Message' in data) {
          showNotification(data.Message);
        }
        if ('Solution' in data && Array.isArray(data.Solution)) {
          const isFullSolution = data.Response === 200;
          revealWordsWithFade(data.Solution, cells, isFullSolution);
        }
        if ('Response' in data && data.Response === 200) {
          setColorInputLocked(true);
        } else {
          setColorInputLocked(false);
        }
      })
      .catch(error => {
        stopLoadingAnimation();
        setColorInputLocked(false);
        showNotification("Error contacting API: " + error);
        console.error("Fetch error:", error);
      });
    });

    document.querySelector('.reset-btn').addEventListener('click', function() {
      resetGrid();
    });

    window.addEventListener('resize', function() {
    });

    // Button for solvable Patterns
    document.addEventListener('DOMContentLoaded', () => {
      const button = document.getElementById("pattern-menu-button");
      const menu = document.getElementById("pattern-menu");
      const inputCells = document.querySelectorAll("#pattern-input .pattern-cell");
      const colorCycle = ['gray', 'green', 'orange'];
      const colorToSymbol = { gray: '#', green: 'G', orange: 'O' };
      const symbolToColor = { '#': '#aaa', 'G': '#4CAF50', 'O': '#FFA500' };

      let patternData = {};

      // Fetch and cache patterns
      async function loadPatternData() {
        if (Object.keys(patternData).length > 0) return;
        try {
          const response = await fetch(`${API_ENDPOINT}/get_all_solutions`);
          patternData = await response.json();
        } catch (err) {
          menu.innerHTML = "<p>Error loading patterns</p>";
        }
      }

      // Get input state as string
      function getCurrentInputPattern() {
        return Array.from(inputCells).map(cell => {
          if (cell.classList.contains('green')) return 'G';
          if (cell.classList.contains('orange')) return 'O';
          return '#';
        }).join('');
      }

      // Match: strict position; # wildcards
      function matchesInput(userPattern, candidatePattern) {
        for (let i = 0; i < userPattern.length; i++) {
          if (userPattern[i] !== '#' && userPattern[i] !== candidatePattern[i]) {
            return false;
          }
        }
        return true;
      }

      // Render results in the slide-in menu
      function renderMatchingPatterns(currentPattern) {
        menu.innerHTML = '';

        const closeBtn = document.createElement('button');
        closeBtn.id = 'close-menu-button';
        closeBtn.textContent = '× Close';
        closeBtn.style.marginBottom = '10px';
        closeBtn.onclick = () => menu.classList.remove('visible');
        menu.appendChild(closeBtn);

        const matched = Object.entries(patternData).filter(([pattern, info]) => {
          return info.Solvable && matchesInput(currentPattern, pattern);
        });

        if (matched.length === 0) {
          menu.innerHTML = "<p>No matches found.</p>";
          return;
        }

        matched.forEach(([pattern, info]) => {
          const row = document.createElement('div');
          row.className = 'pattern-row';
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.marginBottom = '8px';

          pattern.split('').forEach(sym => {
            const box = document.createElement('div');
            box.className = 'pattern-box';
            box.style.backgroundColor = symbolToColor[sym] || '#fff';
            row.appendChild(box);
          });

          const count = document.createElement('span');
          count.textContent = info.Solutions;
          count.style.marginLeft = '10px';
          row.appendChild(count);

          menu.appendChild(row);
        });
      }

      // Cycle colors on the input cells
      inputCells.forEach(cell => {
        let index = 0;
        cell.classList.add('gray');
        cell.addEventListener('click', () => {
          cell.classList.remove(colorCycle[index]);
          index = (index + 1) % colorCycle.length;
          cell.classList.add(colorCycle[index]);
          if (menu.classList.contains('visible')) {
            renderMatchingPatterns(getCurrentInputPattern());
          }
        });
      });

      // Menu button toggles menu & triggers render
      button.addEventListener('click', async () => {
        await loadPatternData();
        const currentPattern = getCurrentInputPattern();
        renderMatchingPatterns(currentPattern);
        menu.classList.toggle('visible');
      });

      // Do NOT close if clicking grid
      document.addEventListener('click', (e) => {
        if (
          !menu.contains(e.target) &&
          !button.contains(e.target) &&
          !document.getElementById('pattern-input').contains(e.target)
        ) {
          menu.classList.remove('visible');
        }
      });
    });
  </script>
</body>
</html>
