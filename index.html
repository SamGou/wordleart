<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wordle-Style Grid (Responsive, Animated, Dark Mode, Loading & Reset, Lock Colors)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #18181b;
      color: #f4f4f5;
      height: 100%;
      width: 100%;
      box-sizing: border-box;
    }
    body {
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .top-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      position: fixed;
      top: 0;
      left: 0;
      padding: 16px 0;
      background: #23232a;
      box-shadow: 0 2px 8px rgba(0,0,0,0.24);
      z-index: 10;
    }
    .btn-group {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
    }
    .solution-btn, .reset-btn {
      padding: 12px 36px;
      background: #2563eb;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-size: 1.25rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    .solution-btn:hover, .reset-btn:hover {
      background: #1e40af;
    }
    .reset-btn {
      background: #44444c;
      color: #f4f4f5;
    }
    .reset-btn:hover {
      background: #787c7e;
    }
    .container {
      margin-top: 120px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 60vh;
      width: 100vw;
      max-width: 100vw;   /* Prevents accidental stretching */
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(5, minmax(48px, 1fr));
      grid-template-rows: repeat(6, minmax(48px, 1fr));
      gap: 0.45vw;
      background: #23232a;
      padding: 1.5vw;
      border-radius: 8px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.25);
      max-width: 600px;    /* Add this line */
      width: 100%;         /* Already present, keep it */
      margin: 0 auto;      /* Add this line to center */
      max-height: 90vh;    /* Optional: limit vertical stretching */
    }
    .cell {
      aspect-ratio: 1 / 1;
      width: 100%;
      height: 100%;
      background: #27272f;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.2rem, 6vw, 2.5rem);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s, opacity 0.4s;
      border: 5px solid #44444c;
      color: #f4f4f5;
      opacity: 1;
      box-sizing: border-box;
    }
    .cell.green { background: #538d4e; color: #fff; }
    .cell.orange { background: #b59f3b; color: #fff; }
    .cell.gray { background: #3a3a3c; color: #fff; }
    .cell.hidden {
      opacity: 0;
    }
    .cell.loading {
      animation: fadeInOut 1s linear infinite;
    }
    .cell.locked {
      cursor: not-allowed;
      opacity: 0.7;
    }
    @keyframes fadeInOut {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
    @keyframes shake {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-8px); }
      40%  { transform: translateX(8px); }
      60%  { transform: translateX(-6px); }
      80%  { transform: translateX(6px); }
      100% { transform: translateX(0); }
    }

    .shake-row {
      animation: shake 0.5s ease;
    }
    
    @keyframes border-fade-red {
      0% {
        border-color: #44444c;
        box-shadow: none;
      }
      10%,
      70% {
        border-color: rgba(236, 17, 17, 0.5);
        box-shadow: 0 0 0 2px rgba(254,90,90,0.14);
      }
      100% {
        border-color: #44444c;
        box-shadow: none;
      }
    }
    .red-border-fade {
      animation: border-fade-red 0.75s;
    }

    .notification {
      position: fixed;
      top: 32px;
      left: 50%;
      transform: translateX(-50%);
      background: #23232a;
      color: #fff;
      padding: 18px 32px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.24);
      font-size: 1.15rem;
      opacity: 0.97;
      z-index: 9999;
      pointer-events: none;
      transition: opacity 0.5s;
      max-width: 90vw;
      text-align: center;
      word-break: break-word;
    }
    .notification.hide {
      opacity: 0;
      transition: opacity 0.5s;
    }
    /* Responsive adjustments */
    @media (max-width: 700px) {
      .container {
        margin-top: 80px;
        min-height: 40vh;
      }
      .grid {
        gap: 2vw;
        padding: 2vw;
        border-radius: 10px;
      }
      .btn-group {
        gap: 12px;
      }
      .solution-btn, .reset-btn {
        padding: 10px 18px;
        font-size: 1rem;
      }
      .notification {
        padding: 12px 8px;
        font-size: 1rem;
      }
    }
    @media (max-width: 450px) {
      .container {
        margin-top: 60px;
      }
      .grid {
        gap: 1vw;
        padding: 1vw;
      }
      .solution-btn, .reset-btn {
        padding: 8px 6px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div class="btn-group">
      <button class="solution-btn">Find solution for today</button>
      <button class="reset-btn">Reset</button>
    </div>
  </div>
  <div class="container">
    <div class="grid" id="wordleGrid"></div>
  </div>
  <div id="notification" class="notification" style="display:none"></div>
  <script>
    const colors = ["green", "orange", "gray"];
    const colorToChar = {
      "green": "G",
      "orange": "O",
      "gray": "#"
    };

    const grid = document.getElementById('wordleGrid');
    let cells = [];
    let colorInputLocked = false;

    for (let row = 0; row < 6; row++) {
      for (let col = 0; col < 5; col++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.state = "2";
        cell.classList.add('gray');
        cell.textContent = "";
        cell.addEventListener('click', function() {
          if (cell.classList.contains('loading') || colorInputLocked) return;
          let state = parseInt(cell.dataset.state);
          state = (state + 1) % colors.length;
          cell.dataset.state = state;
          cell.className = 'cell';
          if (colors[state]) cell.classList.add(colors[state]);
        });
        grid.appendChild(cell);
        cells.push(cell);
      }
    }

    function showNotification(message, duration=2500) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.style.display = 'block';
      notification.classList.remove('hide');
      setTimeout(() => {
        notification.classList.add('hide');
        setTimeout(() => {
          notification.style.display = 'none';
        }, 500);
      }, duration);
    }

    function startLoadingAnimation() {
      cells.forEach(cell => {
        cell.classList.add('loading');
      });
    }
    function stopLoadingAnimation() {
      cells.forEach(cell => {
        cell.classList.remove('loading');
      });
    }

    function revealWordsWithFade(words, cells, isFullSolution) {
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.add("hidden");
        cell.classList.remove("shake-row");
        cell.classList.remove("red-border-fade");
      });

      const totalRows = 6;
      const columns = 5;
      let shakeApplied = false;

      function revealRow(row) {
        if (row >= totalRows) return;

        const word = words[row] || "";
        const isEmpty = word === "";

        for (let col = 0; col < columns; col++) {
          const idx = row * columns + col;
          cells[idx].textContent = word[col] || "";
          void cells[idx].offsetWidth;
          cells[idx].classList.remove('hidden');
        }

        // Apply shake/red-border only if itâ€™s not a full solution
        if (!isFullSolution && isEmpty && !shakeApplied) {
          const rowStart = row * columns;
          for (let i = 0; i < columns; i++) {
            const cell = cells[rowStart + i];
            cell.classList.add("shake-row", "red-border-fade");
            setTimeout(() => {
              cell.classList.remove("red-border-fade");
            }, 1000);
          }
          shakeApplied = true;
        }

        setTimeout(() => revealRow(row + 1), 100);
      }

      revealRow(0);
    }




    function setColorInputLocked(lock) {
      colorInputLocked = lock;
      cells.forEach(cell => {
        if (lock) {
          cell.classList.add('locked');
        } else {
          cell.classList.remove('locked');
        }
      });
    }


    function resetGrid() {
      cells.forEach(cell => {
        cell.textContent = "";
        cell.dataset.state = "2";
        cell.className = "cell gray";  // This resets all classes including hidden/shake
      });
      setColorInputLocked(false);
    }

    document.querySelector('.solution-btn').addEventListener('click', function() {
      let colorString = "";
      cells.forEach(cell => {
        let colorClass = colors[parseInt(cell.dataset.state)];
        colorString += colorToChar[colorClass];
      });

      startLoadingAnimation();
      setColorInputLocked(true);

      fetch("http://192.168.1.210:8080/get_words", { // <-- Replace with your API endpoint!
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ colors: colorString })
      })
      .then(response => response.json())
      .then(data => {
        stopLoadingAnimation();
        if ('Response' in data) {
          console.log("API Response Code:", data.Response);
        }
        if ('Message' in data) {
          showNotification(data.Message);
        }
        if ('Solution' in data && Array.isArray(data.Solution)) {
          const isFullSolution = data.Response === 200;
          revealWordsWithFade(data.Solution, cells, isFullSolution);
        }
        if ('Response' in data && data.Response === 200) {
          setColorInputLocked(true);
        } else {
          setColorInputLocked(false);
        }
      })
      .catch(error => {
        stopLoadingAnimation();
        setColorInputLocked(false);
        showNotification("Error contacting API: " + error);
        console.error("Fetch error:", error);
      });
    });

    document.querySelector('.reset-btn').addEventListener('click', function() {
      resetGrid();
    });

    // Optional: handle window resize for extra polish (force grid redraw if needed)
    window.addEventListener('resize', function() {
      // No action required: CSS handles scaling, but you could add logic here if needed
    });
  </script>
</body>
</html>
